{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\fswiss\fcharset0 Helvetica-Bold;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;\red251\green0\blue7;\red25\green60\blue255;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c93333;\cssrgb\c100000\c12195\c0;\cssrgb\c12594\c35385\c100000;
}
\margl1440\margr1440\vieww15320\viewh22280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 6/17/20\
AA Data Structures/Algorithms Notes\
6- Efficient Sorting Algorithms \
\pard\pardeftab720\sl280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://open.appacademy.io/learn/self-study/data-structures-and-algorithms/quick-sort-notes"}}{\fldrslt 
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
\ul \ulc2 https://open.appacademy.io/learn/self-study/data-structures-and-algorithms/quick-sort-notes}}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\b \cf0 1. \cf3 Merge Sort
\f0\b0 \cf0 \
	- Splits array in half, recursively sorts each half, then merges them\
	- Time Complexity:    O( N log(N) ),  N = input array length\
	log(N) represents the two recursive calls (or the num times it takes for N to reach 1)\
	the first N in N * log(N) represents the while loop in the merge helper function\
	- Space Complexity:  O(N)\
	- When to use: \
		- if you have unlimited memory available\
		- array has rational numbers (radix/counting sort won\'92t work)\
\
\

\f2\b 2. \cf3 Quick Sort
\f0\b0 \cf0 \
	- Choose arbitrary* pivot point,  partition array in two with left being all numb\
	  less than pivot, and right partition being all numbers greater than or equal to pivot. \
           Then recursively sort both halves and join them with pivot. \
	- Time Complexity:    	Average:	O(N log(N)),  N = input array length\
					Best:		O(N log(N)),  \
		- First N in O(N log(N) comes from partitioning step\
		- log(N) part comes if pivot at/near the median, so having occurs during partition/recursive calls \
					Worst: 	O(N^2)	though studies show this rarely occurs\
	- Space Complexity:     Worst:	O(N),		though there exists a O(log(N)) in-place sort\
	- When to use: \
		- easy to read/not that many lines of code (compared to merge sort)\
		- array has rational numbers (radix/counting sort won\'92t work)\
		- if the input array is nearly sorted, then don\'92t use first num as pivot (choose middle or random num!)\
\
\

\f2\b 3. \cf3 Radix Sort
\f0\b0 \cf0 \
	- Non Comparison Sort\
	- Find K (length of longest integer), loop num times equal to K, create bucket of 10 arrays, then loop\
            Through integers and place them in appropriate buckets (by kth digit)\
	- Time Complexity:    	Worst:	O(N * K),  N = input array length, \cf4 K = length of longest integer (maxDigits)\cf0 \
					Best:		O(N log(K)),  \
	- Space Complexity:     Worst:	O(N + K)\
	- When to use: \
		- You have a list of binary data\
		- You have list of integers, and you don\'92t know the value of the largest integer\
		  if you do know the value of the largest integer, use countingSort\
		- Very fast when K is small\
	- Sorting negatives is very simple (just use radixSort as a helper method to sort negatives and positives)\
\
\

\f2\b 4. \cf3 Counting Sort
\f0\b0 \cf0 \
	- Non Comparison Sort, Faster than Radix!!\
	- count num of times each integer appears in array, then because array indices are already sorted, just\
	  push counters index to sorted result array\
	- limited to integers less than about 4.2B (limit of array lengths in ECMA 256 for 32-bit numbers)\
	- Time Complexity:    	Worst:	O(N + M),  N = input array length, \cf4 M = Max (largest) integer in array\cf0 \
	- Space Complexity:     Worst:	O(M)\
	- When to use: \
		- have a list of integers, AND you DO know M = Max (largest) integer in array.\
		  not to be confused with K from radix sort above (length of longest integer)\
		- great for when k is small\
\
\
QUESTIONS\
	- why does knowing/not knowing K (length of longest integer) impact which Algorithm to use?\
	  finding K is just O(N), so you\'92re not actually saving worst time complexity\'85?\
\
\
\
}